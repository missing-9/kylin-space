<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis作为缓存遇到问题点</title>
      <link href="/2021/08/03/hou-duan/redis-zuo-wei-huan-cun-yu-dao-wen-ti-dian/"/>
      <url>/2021/08/03/hou-duan/redis-zuo-wei-huan-cun-yu-dao-wen-ti-dian/</url>
      
        <content type="html"><![CDATA[<p>这篇文章由一篇面试题说起。。。</p><blockquote><p>面试官问，如果线上redis挂了，所有请求都打到了数据库了，然后数据库也挂了。这时应该怎样恢复？</p></blockquote><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><blockquote><p>如果线上 Redis 挂了。然后所有请求打到数据库导致数据库也挂了。</p></blockquote><blockquote><p>redis 挂了 =&gt; 缓存都没了；</p><p>缓存都没有了 =&gt; 缓存雪崩；</p><p>缓存雪崩了 =&gt; 数据库挂了；</p></blockquote><ol><li>缓存全没了：缓存雪崩；</li><li>缓存中没有数据库中有：缓存击穿；</li><li>缓存和数据库中都没有：缓存穿透。</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>redis 挂了，为什么挂了？怎么就挂了？是不是有单点问题</p><p>这就是在问 redis 服务的高可用。</p><p>首先要解答 <strong>这时该怎么进行恢复？</strong></p><p>怎么恢复是正事，“缓存三连击”，“高可用架构”都是预防措施。答肯定要答，从事中恢复过渡到事前预防方案要自然一些。</p><p>服务挂了，先把 redis 和数据库服务重新启动起来。启动之前把流量摘掉，可以先把流量拦截在入口的地方，比如简单粗暴的通过 Nginx 的配置把请求都转到精心设计的错误页面上。这样做的目的是为了防止流量过大，直接把新启动的服务，启动一个打挂一个的情况出现。</p><blockquote><p>要是启动起来又扛不住了，不行就价钱，加机器</p></blockquote><p>加机器没什么技术含量，再从缓存预热的角度往下说。</p><p>当 redis 服务重新启动后，通过程序先放点已知的热点 key 进去后，系统再对外提供服务，防止缓存击穿的场景。</p><p><strong>下面再继续说说事前预防。</strong></p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指一个请求要访问的数据，缓存中没有，但数据库中有的情况。</p><p>这种情况一般来说就是缓存过期了。</p><p>但是这时由于并发访问这个缓存的用户特别多，这是一个热点 key ，这么多用户的请求同时过来，在缓存里面没有取到数据，所以又同时去访问数据库取数据，引起数据库流量激增，压力瞬间增大，直接崩溃。</p><p>所以一个数据有缓存，每次请求都从缓存中快速的返回了数据，但是某个时间点缓存失效了，某个请求在缓存中没有请求到数据，这时候我们就说这个请求“击穿”了缓存。针对这个场景，对应的解决方案一般来说有三种。</p><ul><li><p><strong>第一个就是只放行一个请求到数据库，然后做构建缓存的操作。</strong><br>借助 Redis setNX 命令设置一个标志位就行。设置成功的放行，设置失败的就轮询等待。</p></li><li><p><strong>第二个解决方案就是后台续命</strong><br>这个方案的思想就是，后台开一个定时任务，专门主动更新即将过期的数据。</p></li></ul><p>比如程序中设置 program 这个 key 的时候，同时设置了过期时间为 10 分钟，那后台程序在第 8 分钟的时候，会去数据库查询数据并重新放到缓存中，同时再次设置缓存为10分钟。</p><blockquote><p>有种 redisson 分布式锁看门狗的原理。思想是一脉相承的。按照看门狗的思想就是每个 key （分布式锁）一个监控任务。有一定的性能消耗，所以要做取舍，不用所有 key 都做这种机制。方案落地的时候，从代码编写的角度来说麻烦些。</p></blockquote><blockquote><p>运用这个思想开发一个流水号系统，思路是这样的。</p><p>流水号系统，属于比较关键的系统，为了降低数据库异常对服务带来的冲击，所以服务启动后就会为每种业务系统都预先在缓存中缓存5000个流水号。</p><p>然后后台job定时检查缓存中还剩下多少流水号，如果小于1000个，则再预先生成新的流水号，补充到缓存中，让缓存中的流水号再次回到5000个。</p><p>这样做的好处就是数据库异常后，至少保证还有5000个缓存可以保证上游业务，有一定的时候去恢复数据库。</p><p>也算是一种后台续命的思想。</p></blockquote><ul><li><strong>第三个方法就是：永不过期</strong><br>结合实际场景就是这个key一定是个热点key，会有大量的请求来访问这个数据。而且这个key对应的value不会发生变化。</li></ul><p>其实上面的后台续命思想的最终体现也就是永不过期。</p><p>只是后台续命的思想，会主动更新缓存，适用于缓存会变的场景。会出现缓存不一致的情况，取决于你的业务场景能接受多长时间的缓存不一致。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指一个请求要访问的数据，缓存和数据库中都没有，而用户短时间、高密度的发起这样的请求，每次都打到数据库上，给数据库造成了压力。</p><p>一般来说这是恶意请求。</p><p>两个方案解决</p><p>第一个是缓存空对象。就是在数据库即时没有查询到数据，我们也把这次请求当作key缓存起来， value可以是null。下次同样请求就会命中这个null，缓存层就处理了这个请求，不会对数据库产生压力。</p><p>这样实现起来简单，开发成本很低。这里会衍生出来一道面试题：</p><blockquote><p>对于恶意攻击，请求的时候key往往不相同，且只请求一次，那你要把这些key都缓存起来的话，因为每个key都只请求一次，那还是每次都会请求到数据库，没有保护到数据库。</p></blockquote><p>答案是，布隆过滤器</p><p>布隆过滤器的特性是说某个值存在时，这个值可能不存在。当它说不存在时，那就肯定不存在。</p><p>可以基于这个特性，把已有数据都构建到布隆过滤器里面去。它可以帮忙挡住绝大部分的攻击。</p><blockquote><p>这里有个连环炮的问题：<br>面试官：布隆过滤器容量有限且不支持删除，随着里面内容的增加，误判率就会随之上升。请求，这个问题你们是怎么解决的？</p></blockquote><p>也是两个答题方向。</p><p>首先，不支持删除的话，就换一个支持删除的布隆过滤器的轮子，比如布谷鸟过滤器。或者就是提前重构布隆过滤器。</p><p>比如在容量达到50%的时候，就申请一个新的更大的布隆过滤器来替换掉之前的过滤器。只是需要注意的是，重建你得知道有哪些数据需要进行重建的，所以你得有个地方来记录。比如就是redis、数据库，甚至内存缓存都可以。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指缓存中大多数的数据在同一时间到达过期时间，而查询数据量巨大，这时候，又是缓存中没有，数据库中有的情况了。</p><p>和前面将的缓存击穿不同的是，缓存击穿是指大量的请求并发查询同一条数据。</p><p>缓存雪崩是不同数据都到了过期时间，导致这些数据在缓存中查询不到。</p><p>防止雪崩的方案简单来说就是错峰过期。</p><p>在设置key过期时间的时候，再加上一个短的随机过期时间，这样就能避免大量缓存在同一时间过期，引起的缓存雪崩。</p><h2 id="Redis-高可用架构"><a href="#Redis-高可用架构" class="headerlink" title="Redis 高可用架构"></a>Redis 高可用架构</h2><p>Redis 高可用架构，基本上是主从、哨兵、集群这三种模式。</p><p>主从结构很简单，弊端主要是出现故障的时候需要人工介入干预，需要人工介入的，就是阉割版的高可用。</p><p>哨兵是官网推荐的高可用方案。接下来主要说下哨兵模式。</p><p><img src="https://raw.githubusercontent.com/missing-9/image-store/main/redis.jpg" class="lazyload placeholder" data-srcset="https://raw.githubusercontent.com/missing-9/image-store/main/redis.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="图片"></p><p>哨兵是用来管理多个 Redis 服务的。</p><p>它主要执行三种类型的任务：</p><ul><li>监控（Monitoring）：Sentinel会不断地检查你的主服务器和从服务器是否运作正常。</li><li>提醒（Notification）：当被监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知。</li><li>自动故障迁移（Automatic failover）：当一个主服务器不能正常工作时，Sentinel会开始一次自动故障迁移操作，它会将失效主服务器的其中一个服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，是的集群可以使用新主服务器代替失效服务器。</li></ul><p>哨兵其实也是一个分布式系统，我们可以运行多个哨兵。</p><p>然后这些哨兵之间需要相互通气，交流信息，通过投票来决定是否执行自动故障迁移，以及选择哪个从服务器作为新的主服务器。</p><p>另外，如果主节点挂了，哨兵到底通过什么规则选择新的主节点，也就是选举过程大致是怎么样的，也偶先面试环节。</p><p>这些规则会背就完事了。</p><ul><li>在挂了的主节点下挂的从节点中，被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从节点都没有资格参与选举。</li><li>在挂了的主节点下挂的从节点中，那些与挂了的主节点连接断开的时长超过 down-after 配置指定的时长十倍的从节点都没有资格参与选举。</li><li>经过上面这两轮淘汰之后，剩下来的从服务器中，选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器。如果复制偏移量不可用，或者从服务器的复制偏移量相同，那么带有最小运行 ID 的那个从服务器成为新的主服务器。</li></ul><p>其实执行上面这些操作的，是一个哨兵。而我们的哨兵一般是三个以上，那么那个哨兵来执行这些操作呢？</p><p>其实这个哨兵也是需要从多个哨兵中被选举一个出来的，被选出来的这个哨兵就是领头哨兵(leader Sentinel)。</p><p>选举领头哨兵的时候，采取的是 Raft 算法。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的位运算</title>
      <link href="/2021/07/23/suan-fa/you-qu-de-wei-yun-suan/"/>
      <url>/2021/07/23/suan-fa/you-qu-de-wei-yun-suan/</url>
      
        <content type="html"><![CDATA[<h2 id="两数交换-——-位运算实现"><a href="#两数交换-——-位运算实现" class="headerlink" title="两数交换 —— 位运算实现"></a>两数交换 —— 位运算实现</h2><p>注意：两个数一定不能指向同一内存空间，不然结果都会变成0！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">a = a^b;</span><br><span class="line">b = a^b;</span><br><span class="line">a = a^b;</span><br></pre></td></tr></table></figure><p>二进制异或运算 0^1 , 0^0 , 1^1 。相同为 0 ，不同为 1 。</p><p>运用到具体两个数字上，就是相同两数异或会为 0 ， 0 再异或任何一个非零的数，就是这个数本身。</p><p>异或有交换律和结合律。</p><h2 id="运用实战"><a href="#运用实战" class="headerlink" title="运用实战"></a>运用实战</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p><strong>给一个数组 arr[] ，有一种数出现了奇数次，其它数都出现了偶数次，让你把那出现奇数次的数找出来</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int[] arr=new int[]&#123;2,2,3,3,4,4,5,5,5&#125;;</span><br><span class="line">int res=0;</span><br><span class="line">for (int cur : arr) &#123;</span><br><span class="line">    res ^=cur;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br></pre></td></tr></table></figure><p><strong>给一个数组 arr[] ，有两种数出现了奇数次，其它数都出现了偶数次，让你把那出现奇数次的两种数找出来</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cur : arr) &#123;</span><br><span class="line">    eor ^= cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//eor=a^b</span></span><br><span class="line"><span class="comment">//eor!=0</span></span><br><span class="line"><span class="comment">//eor必然有一个位置为1</span></span><br><span class="line"><span class="keyword">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>);<span class="comment">//提取出最右的1</span></span><br><span class="line"><span class="keyword">int</span> onlyOne = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cur : arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((rightOne &amp; cur) == <span class="number">0</span>) &#123; <span class="comment">//与运算。最右的 1 只有与上 1 才能等于 1 。</span></span><br><span class="line">        onlyOne ^= cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//把其中一个数提取出来了 onlyOne = a || b</span></span><br><span class="line">System.out.println(onlyOne + <span class="string">&quot; &quot;</span> + (eor ^ onlyOne));</span><br></pre></td></tr></table></figure><ul><li>与运算。只有两个位都等于 1 时，结果才为 1</li><li>或运算。只要有 1 个位为 1 ，结果就为 1</li><li>异或运算。如果两个位为“异”（值不同），结果就为 1 。</li></ul><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>算法在<strong>最坏情况</strong>下运行所需时间。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂七杂八瞎捣鼓</title>
      <link href="/2021/07/22/ge-ren-sui-bi/za-qi-za-ba-xia-dao-gu/"/>
      <url>/2021/07/22/ge-ren-sui-bi/za-qi-za-ba-xia-dao-gu/</url>
      
        <content type="html"><![CDATA[<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>消息队列： Kafka/Rabbit MQ/Activi MQ/</p><p>缓存工具：Redis</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Mysql/MongoDB</p><h3 id="服务器端语言"><a href="#服务器端语言" class="headerlink" title="服务器端语言"></a>服务器端语言</h3><p>java/javascript/python/golang</p><h3 id="前端语言"><a href="#前端语言" class="headerlink" title="前端语言"></a>前端语言</h3><p>javascript</p><h3 id="后端框架"><a href="#后端框架" class="headerlink" title="后端框架"></a>后端框架</h3><p>SpringCloud全家桶</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>排序算法：简单排序算法、选择排序算法、冒泡排序、桶排序算法、二分查找</p><p>算法思想：动态规划</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>二叉树、树形结构、图、链表、数组、散列表</p>]]></content>
      
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 瞎捣鼓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我高估自制力良好</title>
      <link href="/2021/07/20/ge-ren-sui-bi/zi-wo-gao-gu-zi-zhi-li-liang-hao/"/>
      <url>/2021/07/20/ge-ren-sui-bi/zi-wo-gao-gu-zi-zhi-li-liang-hao/</url>
      
        <content type="html"><![CDATA[<p>我好像从小到大，对自我都会很高估，总是认为自己能做出来多么多么了不起的事情来，看到那些由衷敬佩的先驱者们，我有的时候在读他们的传记或者故事时，竟然会时不时的认为自己也能做出那些。心比天高，到头来发现自己什么也不是，然后又对产生能力的怀疑。我就是在这种恶性循环里长大的。很讨厌这种感觉，我有时候会问自己，这种状态是一个人该有的状态吗？会对生活或者人生起积极作用吗？</p><p>看好多人都对自己进行年终总结啊，什么来年规划啊。我就学着做，上一个月，我活在每天给自己定的计划中，按计划生活，半个月前，我彻底不受控制了，一到凌晨就很嗨，脑子里心里都在给自己暗示，我白天都是在完成计划，只有现在是属于我自己时间的，尽情嗨起来吧。呵呵，觉也不愿意睡了，现在想想都很嫌弃那时的状态。</p><p>要说到计划，我其实有很多计划，也对自己有很多期望，计划一旦需要坚持，我就歇菜了，我本以为自己自制力不错，可一旦进入有规律的有计划的生活，我潜意识里就会对自己说，你难道是机器人，你难道没有别的想做的事情。时间空下来准备开始完成计划的时候，总是有一个人对我说，再看会手机吧，再刷会视频吧，再推迟个几分钟再开始执行计划吧，反正计划都定好了， 晚点加快速度执行就行了。就这样，1分钟，5分钟，10分钟过去了。</p><p>我是很羡慕那些自己独自一人就能更新视频，更新文章，更新技术的人的，他们独自一人的时候没有变呆变笨。</p><p>原本这个时间点，我计划是。。好像没有明确定下来我现在要干什么。刚准备要鸡血起来，我发现我困了。。。一天就这样过去了。。。</p><p>附一个网站链接。没想到是微软的人，看了他的随感，我内心会比较平静。<br><a href="https://cuiqingcai.com/">https://cuiqingcai.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人随笔 </tag>
            
            <tag> 自制力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书大本营</title>
      <link href="/2021/07/03/du-shu-da-ben-ying/"/>
      <url>/2021/07/03/du-shu-da-ben-ying/</url>
      
        <content type="html"><![CDATA[<h3 id="Distributed-Algorithms-An-Intuitive-Approach"><a href="#Distributed-Algorithms-An-Intuitive-Approach" class="headerlink" title="Distributed Algorithms: An Intuitive Approach"></a>Distributed Algorithms: An Intuitive Approach</h3><p>Distributed Algorithms: An Intuitive Approach: Wan Fokkink: 9780262026772: Amazon.com: Books<br>分布式算法书。篇幅短，介绍直白。<br>在线阅读地址：<a href="https://ftp.utcluj.ro/pub/users/civan/CPD/1_RESURSE_CURS/Books/Book_2015_Fokkink_Distributed%20Algorithms.pdf">https://ftp.utcluj.ro/pub/users/civan/CPD/1_RESURSE_CURS/Books/Book_2015_Fokkink_Distributed%20Algorithms.pdf</a></p><h3 id="程序员的自我修养"><a href="#程序员的自我修养" class="headerlink" title="程序员的自我修养"></a>程序员的自我修养</h3><p>《程序员的自我修养》电子书：2021-07-17——2021-07-18读完。</p><p>感受较真实，评价一般。文风较朴实。</p><h3 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h3><p>《算法图解》纸质书，断断续续读了有半年之久，还没读完。。</p>]]></content>
      
      
      <categories>
          
          <category> 读书大本营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法实战系列之全排列问题</title>
      <link href="/2021/06/27/suan-fa/hui-su-suan-fa-shi-zhan-xi-lie-zhi-quan-pai-lie-wen-ti/"/>
      <url>/2021/06/27/suan-fa/hui-su-suan-fa-shi-zhan-xi-lie-zhi-quan-pai-lie-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="题目实例Ⅰ"><a href="#题目实例Ⅰ" class="headerlink" title="题目实例Ⅰ"></a>题目实例Ⅰ</h3><p><strong>784. 字母大小写全排列</strong></p><p>给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。</p><p>示例 1：</p><blockquote><p>输入：S = “a1b2”</p><p>输出：[“a1b2”, “a1B2”, “A1b2”, “A1B2”]</p></blockquote><p>示例 2：</p><blockquote><p>输入：S = “3z4”</p><p>输出：[“3z4”, “3Z4”]</p></blockquote><p>示例 3：</p><blockquote><p>输入：S = “12345”</p><p>输出：[“12345”]</p></blockquote><p>提示：</p><ul><li>S 的长度不超过12。</li><li>S 仅由数字和字母组成。</li></ul><p>友情链接：<a href="https://leetcode-cn.com/problems/letter-case-permutation/">https://leetcode-cn.com/problems/letter-case-permutation/</a></p><h3 id="代码实战Ⅰ"><a href="#代码实战Ⅰ" class="headerlink" title="代码实战Ⅰ"></a>代码实战Ⅰ</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backTracking(s, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(String s, ArrayList&lt;String&gt; res, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.length() == s.length()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(path.toString()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(ch)) &#123;</span><br><span class="line">                path.append(ch);</span><br><span class="line">                backTracking(s, res, i + <span class="number">1</span>);</span><br><span class="line">                path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                path.append(Character.toLowerCase(ch));</span><br><span class="line">                backTracking(s, res, i + <span class="number">1</span>);</span><br><span class="line">                path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                path.append(Character.toUpperCase(ch));</span><br><span class="line">                backTracking(s, res, i + <span class="number">1</span>);</span><br><span class="line">                path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93356abf8c074eccac4688a4806df115~tplv-k3u1fbpfcp-watermark.image" class="lazyload placeholder" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93356abf8c074eccac4688a4806df115~tplv-k3u1fbpfcp-watermark.image" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image.png"></p><h3 id="题目实例Ⅱ"><a href="#题目实例Ⅱ" class="headerlink" title="题目实例Ⅱ"></a>题目实例Ⅱ</h3><p><strong>47. 全排列 II</strong></p><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p>示例 1：</p><blockquote><p>输入：nums = [1,1,2]</p><p>输出：</p><p>[[1,1,2],</p><p>[1,2,1],</p><p>[2,1,1]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [1,2,3]</p><p>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p></blockquote><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 8</li><li>-10 &lt;= nums[i] &lt;= 10</li></ul><p>友情链接：<a href="https://leetcode-cn.com/problems/permutations-ii/">https://leetcode-cn.com/problems/permutations-ii/</a></p><h3 id="代码实战Ⅱ"><a href="#代码实战Ⅱ" class="headerlink" title="代码实战Ⅱ"></a>代码实战Ⅱ</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backTracking(nums, used, path, depth, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, LinkedList&lt;Integer&gt; path, <span class="keyword">int</span> depth, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == depth) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                backTracking(nums, used, path, depth + <span class="number">1</span>, res);</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31d9faf5dea64c96934295a1ae01029f~tplv-k3u1fbpfcp-watermark.image" class="lazyload placeholder" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31d9faf5dea64c96934295a1ae01029f~tplv-k3u1fbpfcp-watermark.image" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL连表查询分组去重实例</title>
      <link href="/2021/06/27/hou-duan/mysql-lian-biao-cha-xun-fen-zu-qu-chong-shi-li/"/>
      <url>/2021/06/27/hou-duan/mysql-lian-biao-cha-xun-fen-zu-qu-chong-shi-li/</url>
      
        <content type="html"><![CDATA[<h2 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h2><p>通过多种渠道将小程序的活动页链接发布出去，比如通过多多种短信附带链接( channel 就记为 sms1，sms2，sms3 )，或者海报上面贴微信小程序的二维码( channel 记为 qrcode1，qrcode2，qrcode3 )，线下会员通过扫描二维码也能进入小程序指定的活动页，亦或者是通过其他会员分享的小程序链接也可以进入小程序( channel 记为 share)。这些不同的进入方式在我这篇文章统称为不同的渠道，也就是提到的 channel 字段。从不同的渠道进入活动页就会产生一条页面访问记录。会被计入 page_view 这张表里。</p><p>会员进入小程序的指定活动页后，在页面上面触发一系列操作后，会得到相应的反馈，比如获得积分，或者获得优惠券等等。这步操作称为参与活动。这条数据会被记入 activity_record 这张表里。</p><p>现在呢，运营小姐姐要求得到一份数据报表。每位参与活动的会员是从什么时间,哪个渠道里面进活动的？</p><h2 id="数据表结构"><a href="#数据表结构" class="headerlink" title="数据表结构"></a>数据表结构</h2><table><thead><tr><th>表名</th><th>member_id</th><th>participate_time</th></tr></thead><tbody><tr><td>activity_record</td><td>会员号</td><td>活动参与时间</td></tr></tbody></table><table><thead><tr><th>表名</th><th>member_id</th><th>channel</th><th>view_time</th></tr></thead><tbody><tr><td>page_view</td><td>会员号</td><td>渠道</td><td>页面访问时间</td></tr></tbody></table><h2 id="查询逻辑"><a href="#查询逻辑" class="headerlink" title="查询逻辑"></a>查询逻辑</h2><p>因为每位会员只能参加一次活动，也就是活动期间只能获得过一次积分，或者领取过一次优惠券等等这种意思，也就是每位会员最多只会产生一条 activity_record 记录。</p><p>可是 page_view 这张表的记录方式就不一样了。会员可能既收到过短信链接，又扫描过活动二维码，又被好友分享过活动链接，这下，对于这位会员来说，就会产生多条页面访问记录，即在 page_view 里产生多条数据。</p><p>你想想，会员肯定是先通过某一个渠道进入到活动页面，才能去参加活动。也就是有多条 page_view 的数据，按照 view_time 倒序排列，总有一条的 view_time 是小于且最接近于 activity_record 的 participate_time，下一条 page_view 的 view_time 就会大于 activity_record 的 participate_time。</p><h2 id="SQL脚本"><a href="#SQL脚本" class="headerlink" title="SQL脚本"></a>SQL脚本</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.member_id,c.view_time,.channel <span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">member_id,</span><br><span class="line">SUBSTRING_INDEX( GROUP_CONCAT( view_time <span class="keyword">ORDER</span> <span class="keyword">BY</span> view_time <span class="keyword">DESC</span> ), <span class="string">&#x27;,&#x27;</span>, <span class="number">1</span> ) <span class="keyword">AS</span> view_time,</span><br><span class="line">SUBSTRING_INDEX( GROUP_CONCAT( channel <span class="keyword">ORDER</span> <span class="keyword">BY</span> channel <span class="keyword">DESC</span> ), <span class="string">&#x27;,&#x27;</span>, <span class="number">1</span> ) <span class="keyword">AS</span> channel</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">page_view a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> activity_record b</span><br><span class="line">        <span class="keyword">on</span> a.member_id <span class="operator">=</span> b.member_id</span><br><span class="line">        <span class="keyword">where</span> a.view_time <span class="operator">&lt;</span> b.participate_time</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">member_id) c;</span><br></pre></td></tr></table></figure><h2 id="脚本说明"><a href="#脚本说明" class="headerlink" title="脚本说明"></a>脚本说明</h2><ul><li>GROUP_CONCAT：通过使用distinct可以排除重复值； group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’] )</li><li>SUBSTRING_INDEX：字符串截取函数。substring_index(str,delim,count)。str:要处理的字符串；delim:分隔符；count:计数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2021/06/20/suan-fa/kuai-su-pai-xu/"/>
      <url>/2021/06/20/suan-fa/kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<p>快速排序算法由 C. A. R. Hoare 在 1960 年提出。它的时间复杂度也是 O(nlogn)，但它在时间复杂度为O(nlogn)级的几种排序算法中，大多数情况下效率更高，所以快速排序的应用非常广泛。再加上快速排序所采用的分治思想非常实用，使得快速排序深受面试官的青睐，所以掌握快速排序的思想尤为重要。</p><p>快速排序算法的基本思想是：</p><ul><li>从数组中取出一个数，称之为基数（pivot）</li><li>遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域</li><li>将左右两个区域视为两个数组，重复前两个步骤，直到排序完成</li></ul><p>事实上，快速排序的每一次遍历，都将基数摆到了最终位置上。第一轮遍历排好 1 个基数，第二轮遍历排好 2 个基数（每个区域一个基数，但如果某个区域为空，则此轮只能排好一个基数），第三轮遍历排好 4 个基数（同理，最差的情况下，只能排好一个基数），以此类推。总遍历次数为 logn～n 次，每轮遍历的时间复杂度为O(n)，所以很容易分析出快速排序的时间复杂度为 O(nlogn)～ O(n^2)平均时间复杂度为O(nlogn)。</p><p><em>让我们来看一下快速排序的动图吧</em></p><p><img src="/medias/images/QUI.gif" class="lazyload placeholder" data-srcset="/medias/images/QUI.gif" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image.png"></p><h2 id="快速排序递归框架"><a href="#快速排序递归框架" class="headerlink" title="快速排序递归框架"></a>快速排序递归框架</h2><p>根据我们分析出的思路，先搭出快速排序的架子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">  <span class="keyword">int</span> middle = partition(arr, start, end);</span><br><span class="line">  <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">  quickSort(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">  quickSort(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>partition 意为“划分”，我们期望 partition 函数做的事情是：将 arr 从 start 到 end 这一区间的值分成两个区域，左边区域的每个数都比基数小，右边区域的每个数都比基数大，然后返回中间值的下标。</p></blockquote><p>只要有了这个函数，我们就能写出快速排序的递归函数框架。首先调用 partition 函数得到中间值的下标 middle，然后对左边区域执行快速排序，也就是递归调用 quickSort(arr, start, middle - 1)，再对右边区域执行快速排序，也就是递归调用 quickSort(arr, middle + 1, end)。</p><p>现在还有一个问题，何时退出这个递归函数呢？</p><h2 id="退出递归的边界条件"><a href="#退出递归的边界条件" class="headerlink" title="退出递归的边界条件"></a>退出递归的边界条件</h2><p>很容易想到，当某个区域只剩下一个数字的时候，自然不需要排序了，此时退出递归函数。实际上还有一种情况，就是某个区域只剩下 0 个数字时，也需要退出递归函数。当 middle 等于 start 或者 end 时，就会出现某个区域剩余数字为 0。</p><p>所以我们可以通过这种方式退出递归函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">  <span class="keyword">int</span> middle = partition(arr, start, end);</span><br><span class="line">  <span class="comment">// 当左边区域中至少有 2 个数字时，对左边区域快速排序</span></span><br><span class="line">  <span class="keyword">if</span> (start != middle &amp;&amp; start != middle - <span class="number">1</span>) quickSort(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 当右边区域中至少有 2 个数字时，对右边区域快速排序</span></span><br><span class="line">  <span class="keyword">if</span> (middle != end &amp;&amp; middle != end - <span class="number">1</span>) quickSort(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在递归之前，先判断此区域剩余数字是否为 0 个或者 1 个，当数字至少为 2 个时，才执行这个区域的快速排序。因为我们知道 middle &gt;= start &amp;&amp; middle &lt;= end 必然成立，所以判断剩余区域的数字为 0 个或者 1 个也就是指 start 或 end 与 middle 相等或相差 1。</p><p>我们来分析一下这四个判断条件：</p><p>当 start == middle 时，相当于 quickSort(arr, start, middle - 1) 中的 start == end + 1</p><p>当 start == middle - 1 时，相当于 quickSort(arr, start, middle - 1) 中的 start == end</p><p>当 middle == end时，相当于 quickSort(arr, middle + 1, end) 中的 start == end + 1</p><p>当 middle == end -1时，相当于 quickSort(arr, middle + 1, end) 中的 start == end</p><p>综上，我们可以将此边界条件统一移到 quickSort 函数之前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">quickSortRecurison</span><span class="params">(arr []<span class="keyword">int</span>,start,end <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> start == end || start = end + <span class="number">1</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">  &#125;</span><br><span class="line">  middle = partition(arr,start,end)</span><br><span class="line">  quickSortRecurison(arr,start,middle-<span class="number">1</span>)</span><br><span class="line">  qucikSortRecurison(arr,midlle+<span class="number">1</span>,end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更进一步，由上文所说的 middle &gt;= start &amp;&amp; middle &lt;= end 可以推出，除了start == end || start == end + 1这两个条件之外，其他的情况下 start 都小于 end。所以我们可以将这个判断条件再次简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">quickSortRecurison</span><span class="params">(arr []<span class="keyword">int</span>,start,end <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> start &gt;= end&#123;</span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">  &#125;</span><br><span class="line">  middle := partition(arr,start,end)</span><br><span class="line">  quickSortRecurison(arr,start,middle-<span class="number">1</span>)</span><br><span class="line">  quickSortRecursion(arr,midlle+<span class="number">1</span>,end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就写出了最简洁版的边界条件，我们需要知道，这里的 start &gt;= end 实际上只有两种情况：</p><ul><li>start == end: 表明区域内只有一个数字</li><li>start == end + 1: 表明区域内一个数字也没有<br>不会存在 start 比 end 大 2 或者大 3 之类的。</li></ul><h2 id="分区算法实现"><a href="#分区算法实现" class="headerlink" title="分区算法实现"></a>分区算法实现</h2><p>快速排序中最重要的便是分区算法，也就是 partition 函数。大多数人都能说出快速排序的整体思路，但实现起来却很难一次写对。主要问题就在于分区时存在的各种边界条件，需要读者亲自动手实践才能加深体会。</p><p>上文已经说到，partition 函数需要做的事情就是将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标。那么首先我们要做的事情就是选择一个基数，基数我们一般称之为 pivot，意为“轴”。整个数组就像围绕这个轴进行旋转，小于轴的数字旋转到左边，大于轴的数字旋转到右边。</p><h2 id="基数的选择"><a href="#基数的选择" class="headerlink" title="基数的选择"></a>基数的选择</h2><p>基数的选择没有固定标准，随意选择区间内任何一个数字做基数都可以。通常来讲有三种选择方式：</p><ul><li>选择第一个元素作为基数</li><li>选择最后一个元素作为基数</li><li>选择区间内一个随机元素作为基数</li></ul><p>选择的基数不同，算法的实现也不同。实际上第三种选择方式的平均时间复杂度是最优的，待会分析时间复杂度时我们会详细说明。</p><p>本文通过第一种方式来讲解快速排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">partition</span><span class="params">(arr []<span class="keyword">int</span>,start,end <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  <span class="comment">//取第一个数为基数</span></span><br><span class="line">  pivot := arr[start]</span><br><span class="line">  <span class="comment">//从第二个数开始分区</span></span><br><span class="line">  left = start + <span class="number">1</span></span><br><span class="line">  <span class="comment">//右边界</span></span><br><span class="line">  right = end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最简单的分区算法"><a href="#最简单的分区算法" class="headerlink" title="最简单的分区算法"></a>最简单的分区算法</h2><p>分区的方式也有很多种，最简单的思路是：从 left 开始，遇到比基数大的数，就交换到数组最后，并将 right 减一，直到 left 和 right 相遇，此时数组就被分成了左右两个区域。再将基数和中间的数交换，返回中间值的下标即可。</p><p>按照这个思路，我们敲出了如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">swap</span><span class="params">(arr []<span class="keyword">int</span>,i,j <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  arr[i] = arr[i] ^ arr[j]</span><br><span class="line">  arr[j] = arr[j] ^ arr[i]</span><br><span class="line">  arr[i] = arr[i] ^ arr[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">quickSort</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  quickSortRecursion(arr,<span class="number">0</span>,len(arr)-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">quickSortRecursion</span><span class="params">(arr []<span class="keyword">int</span>,start,end <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">  &#125;</span><br><span class="line">  middle := partition(arr,start,end)</span><br><span class="line">  quickSortRecursion(arr,start,middle-<span class="number">1</span>)</span><br><span class="line">  quickSortRecursion(arr,middle+<span class="number">1</span>,end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">partition</span><span class="params">(arr []<span class="keyword">int</span>,start,end <span class="keyword">int</span>)</span><span class="keyword">int</span></span>&#123;</span><br><span class="line">  pivot := start</span><br><span class="line">  left = start + <span class="number">1</span></span><br><span class="line">  right = end</span><br><span class="line">  <span class="keyword">for</span> left &lt; right&#123;</span><br><span class="line">      <span class="keyword">for</span> arr[left] &lt;= pivot &amp;&amp; left &lt; right&#123;</span><br><span class="line">          left ++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//left找到大于基数的数，停下来</span></span><br><span class="line">      <span class="keyword">if</span> left != right&#123;</span><br><span class="line">          swap(arr,left,right)</span><br><span class="line">          right--</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> left == right &amp;&amp; arr[right] &gt; pivot&#123;</span><br><span class="line">      right--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> left != start&#123;</span><br><span class="line">      swap(arr,left,start)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们选择了数组的第一个元素作为基数，并且分完区后，会执行将基数和中间值交换的操作，这就意味着交换后的中间值会被分到左边区域。所以我们需要保证中间值的下标是分区完成后，最后一个比基数小的值，这里我们用 right 来记录这个值。</p><p>这段代码有一个细节。首先，在交换 left 和 right 之前，我们判断了 left != right，这是因为如果剩余的数组都比基数小，则 left 会加到 right 才停止，这时不应该发生交换。因为 right 已经指向了最后一个比基数小的值。</p><p>但这里的拦截可能会拦截到一种错误情况，如果剩余的数组只有最后一个数比基数大，left 仍然加到 right 停止了，但我们并没有发生交换。所以我们在退出循环后，单独比较了 arr[right] 和 pivot。</p><p>实际上，这行单独比较的代码非常巧妙，一共处理了三种情况：</p><ul><li>一是刚才提到的剩余数组中只有最后一个数比基数大的情况</li><li>二是 left 和 right 区间内只有一个值，则初始状态下， left == right，所以 while (left &lt; right) 根本不会进入，所以此时我们单独比较这个值和基数的大小关系</li><li>三是剩余数组中每个数都比基数大，此时 right 会持续减小，直到和 left 相等退出循环，此时 left 所在位置的值还没有和 pivot 进行比较，所以我们单独比较 left 所在位置的值和基数的大小关系</li></ul><h2 id="双指针分区算法"><a href="#双指针分区算法" class="headerlink" title="双指针分区算法"></a>双指针分区算法</h2><p>除了上述的分区算法外，还有一种双指针的分区算法更为常用：从 left 开始，遇到比基数大的数，记录其下标；再从 right 往前遍历，找到第一个比基数小的数，记录其下标；然后交换这两个数。继续遍历，直到 left 和 right 相遇。然后就和刚才的算法一样了，交换基数和中间值，并返回中间值的下标。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">quickSort</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  quickSortRescursion(arr,<span class="number">0</span>,len(arr)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">quickSortRescursion</span><span class="params">(arr []<span class="keyword">int</span>,start,end <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//求分区中轴，把数组分区</span></span><br><span class="line">  middle := partition(arr,start,end)</span><br><span class="line">  <span class="comment">//向左分区递归，对左分区进行排序</span></span><br><span class="line">  quickSortRescursion(arr,start,middle-<span class="number">1</span>)</span><br><span class="line">  <span class="comment">//向右分区递归，对右分区进行排序</span></span><br><span class="line">  quickSortRescursion(arr,middle+<span class="number">1</span>,end)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">partition</span><span class="params">(arr []<span class="keyword">int</span>,start,end <span class="keyword">int</span>)</span><span class="keyword">int</span></span>&#123;</span><br><span class="line">  <span class="comment">//基数</span></span><br><span class="line">  pivot := arr[start]</span><br><span class="line">  left := start+<span class="number">1</span></span><br><span class="line">  right := end</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> left &lt; right&#123;</span><br><span class="line">      <span class="keyword">for</span> left &lt; right &amp;&amp; arr[left] &lt;= pivot&#123;</span><br><span class="line">          left++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> left &lt; right &amp;&amp; arr[right] &gt;= pivot&#123;</span><br><span class="line">          right--</span><br><span class="line">      &#125; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> left &lt; right&#123;</span><br><span class="line">          swap(arr,left,right)</span><br><span class="line">          left++</span><br><span class="line">          right--</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 如果 left 和 right 相等，单独比较 arr[right] 和 pivot</span></span><br><span class="line">  <span class="keyword">if</span> left == right &amp;&amp; arr[right] &gt; pivot&#123;</span><br><span class="line">      right--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将基数和轴交换</span></span><br><span class="line">  <span class="keyword">if</span> right != start&#123;</span><br><span class="line">  swap(arr,right,start)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，我们需要在退出循环后，单独比较 left 和 right 的值。</p><h2 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><p>平均时间复杂度为O(nlogn)，最坏的时间复杂度为O(n^2)，空间复杂度与递归的层数有关，每层递归会生成一些临时变量，所以空间复杂度为 O(logn)~ O(n)，平均空间复杂度为O(logn)</p><p>为什么说随机选择剩余数组中的一个元素作为基数的方案平均复杂度是最优的呢？什么情况下快速排序算法的时间复杂度最高，一共有两种情况。</p><ul><li>数组为正序</li><li>数组为逆序</li></ul><p>理想中的快速排序在第 k 轮遍历中，可以排好 2^(k-1)个基数。但从图中我们发现，当数组原本为正序或逆序时，我们将第一个数作为基数的话，每轮分区后，都有一个区域是空的，也就是说数组中剩下的数字都被分到了同一个区域！这就导致了每一轮遍历只能排好一个基数。所以总的比较次数为 (n - 1) + (n - 2) + (n - 3) + … + 1 次，由等差数列求和公式可以计算出总的比较次数为 n(n - 1)/2 次，此时快速排序的时间复杂度达到了 O(n^2)级。</p><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>从代码实现中可以分析出，快速排序是一种不稳定的排序算法，在分区过程中，相同数字的相对顺序可能会被修改。</p><h2 id="快速排序的优化思路"><a href="#快速排序的优化思路" class="headerlink" title="快速排序的优化思路"></a>快速排序的优化思路</h2><ul><li>1.每轮选择基数时，从剩余的数组中随机选择一个数字作为基数。这样每轮都选到最大或最小值的概率就会变得很低了。所以我们才说用这种方式选择基数，其平均时间复杂度是最优的</li><li>2.三数取中，待排序序列中low、mid、high三个位置上数据进行排序，取他们中间的那个数据作为枢轴，并用0下标元素存储枢轴。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桶排序入门</title>
      <link href="/2021/06/19/suan-fa/tong-pai-xu-jie-shao/"/>
      <url>/2021/06/19/suan-fa/tong-pai-xu-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>桶排序是一个排序算法，原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。</p><p>桶排序以下列程序进行：</p><ol><li>设置一个定量的数组当作空桶子。</li><li>寻访序列，并且把项目一个一个放到对应的桶子里。</li><li>对每个不是空的桶子进行排序。</li><li>从不是空的桶子里把项目再放回原来的序列中。</li></ol><p><img src="https://gitee.com/missingnine/own-image-store/raw/master/202106/bucket-sort1.png" class="lazyload placeholder" data-srcset="https://gitee.com/missingnine/own-image-store/raw/master/202106/bucket-sort1.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image.png"><br><img src="https://gitee.com/missingnine/own-image-store/raw/master/202106/bucket-sort2.png" class="lazyload placeholder" data-srcset="https://gitee.com/missingnine/own-image-store/raw/master/202106/bucket-sort2.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image.png"></p><blockquote><p>把数组的一组数按照 0-9，10-19， 20-29 这种规律进行分组，也就是分桶。</p><p>再在每一个桶里将数字进行排序。</p></blockquote><h2 id="从简单入门"><a href="#从简单入门" class="headerlink" title="从简单入门"></a>从简单入门</h2><p>王老师的补习班一共教 5 位小朋友，王老师让这 5 位小朋友做了一道 10 分智力算法题，5 位小朋友分别获得了不同的分数：7，5，7，8，7，5。现在需要将这 5 个分数按照从小到大的顺序打印出来。</p><p>首先，我们初始化一个长度为 11 的数组 score[]，0-10 的位置分别对应 10 分的分数。</p><p>于是，我们可以得到这样一个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">score[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//没有小朋友得过 0 分</span></span><br><span class="line">score[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//没有小朋友得过 1 分</span></span><br><span class="line">score[<span class="number">2</span>]=<span class="number">0</span>;<span class="comment">//没有小朋友得过 2 分</span></span><br><span class="line">score[<span class="number">3</span>]=<span class="number">0</span>;<span class="comment">//没有小朋友得过 3 分</span></span><br><span class="line">score[<span class="number">4</span>]=<span class="number">0</span>;<span class="comment">//没有小朋友得过 4 分</span></span><br><span class="line">score[<span class="number">5</span>]=<span class="number">2</span>;<span class="comment">//有 2 个小朋友得过 5 分</span></span><br><span class="line">score[<span class="number">6</span>]=<span class="number">0</span>;<span class="comment">//没有小朋友得过 6 分</span></span><br><span class="line">score[<span class="number">7</span>]=<span class="number">3</span>;<span class="comment">//有 3 个小朋友得过 7 分</span></span><br><span class="line">score[<span class="number">8</span>]=<span class="number">1</span>;<span class="comment">//有 1 个小朋友得过 8 分</span></span><br><span class="line">score[<span class="number">9</span>]=<span class="number">0</span>;<span class="comment">//没有小朋友得过 9 分</span></span><br><span class="line">score[<span class="number">10</span>]=<span class="number">0</span>;<span class="comment">//没有小朋友得过 10 分</span></span><br></pre></td></tr></table></figure><p>最终，我们只要顺序遍历这个数组，值为 0 的就不打印位置，值不为 0 就打印出来数组代表的分数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// score[0]~score[4] 都不打印</span></span><br><span class="line"><span class="number">5</span>,<span class="number">5</span> <span class="comment">//score[5]=2, 有 2 个小朋友得过 5 分</span></span><br><span class="line"><span class="comment">// score[6]=0，不打印</span></span><br><span class="line"><span class="number">7</span>，<span class="number">7</span>，<span class="number">7</span> <span class="comment">//score[7]=3，有 3 个小朋友得过 7 分</span></span><br><span class="line"><span class="number">8</span> <span class="comment">//score[8]=1，有 1 个小朋友得过 8 分</span></span><br><span class="line"><span class="comment">// score[9], score[10]=0，不打印</span></span><br></pre></td></tr></table></figure><p>这里就是把数组的每个位置当作一个桶，每种分数的获得人数就是数组元素。这种是最简易版的桶排序算法的实现。但是真正的桶排序算法是比这种复杂多了。这个小示例只是作为入门的理解之用。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>922. 按奇偶排序数组II</title>
      <link href="/2021/06/19/suan-fa/922.an-qi-ou-pai-xu-shu-zu-ii/"/>
      <url>/2021/06/19/suan-fa/922.an-qi-ou-pai-xu-shu-zu-ii/</url>
      
        <content type="html"><![CDATA[<p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p><p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p><p>你可以返回任何满足上述条件的数组作为答案。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2021/06/19/suan-fa/mou-pao-pai-xu/"/>
      <url>/2021/06/19/suan-fa/mou-pao-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“冒泡排序法除了它迷人的名字和导致了某些有趣的理论问题这一事实外，似乎没有什么值得推荐的。”  ———— Donald E. Knuth（1974 年图灵奖获得者）</p></blockquote><p><img src="https://gitee.com/missingnine/own-image-store/raw/master/202106/bubbleSort.gif" class="lazyload placeholder" data-srcset="https://gitee.com/missingnine/own-image-store/raw/master/202106/bubbleSort.gif" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="bubbleSort.gif"></p><h4 id="1-基本实现"><a href="#1-基本实现" class="headerlink" title="1. 基本实现"></a>1. 基本实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">189</span>, -<span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">78</span>&#125;;</span><br><span class="line">    bubbleSort2(arr);</span><br><span class="line">    Arrays.stream(arr).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环进行了 &quot;</span>+ count +<span class="string">&quot; 次&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">循环进行了 <span class="number">15</span> 次</span><br><span class="line">-<span class="number">6</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">78</span></span><br><span class="line"><span class="number">189</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-优化版本1"><a href="#2-优化版本1" class="headerlink" title="2. 优化版本1"></a>2. 优化版本1</h4><p>在循环遍历过程中记录了是否排过序的状态。如果某一批次中已经开始不进行排序了。就证明从头元素开始的那串剩下数组元素已经是排序正确的了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">189</span>, -<span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">78</span>&#125;;</span><br><span class="line">    bubbleSort2(arr);</span><br><span class="line">    Arrays.stream(arr).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    Boolean swaped = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!swaped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swaped = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                swaped = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">循环进行了 <span class="number">9</span> 次</span><br><span class="line">-<span class="number">6</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">78</span></span><br><span class="line"><span class="number">189</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-优化版本2"><a href="#3-优化版本2" class="headerlink" title="3. 优化版本2"></a>3. 优化版本2</h4><p>此版本在优化版本1的基础上，再做一层优化，多引入一个变量，专门记录最后一个进行过交换的数组元素的位置。这个优化的作用是在没轮次的循环中尽可能的减少比较交换的次数。如果在某个位置之后的元素两两比较，但都没有产生过元素交换动作，那就证明从这个位置之后的元素都是有序的了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">189</span>, -<span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">78</span>&#125;;</span><br><span class="line">    bubbleSort2(arr);</span><br><span class="line">    Arrays.stream(arr).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> swapped = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length, lastSwappedIndex = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (swapped) &#123;</span><br><span class="line">        swapped = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> tempLastUpdateIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lastSwappedIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="keyword">true</span>;</span><br><span class="line">                tempLastUpdateIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        lastSwappedIndex = tempLastUpdateIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环进行了 &quot;</span> + count + <span class="string">&quot; 次&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">循环进行了 <span class="number">9</span> 次</span><br><span class="line">-<span class="number">6</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">78</span></span><br><span class="line"><span class="number">189</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2021/06/19/suan-fa/xuan-ze-pai-xu/"/>
      <url>/2021/06/19/suan-fa/xuan-ze-pai-xu/</url>
      
        <content type="html"><![CDATA[<p>相对于冒泡排序，选择排序多一个变量，专门存储最小值、最大值的下标，等每轮次循环遍历结束后，才会进行两个元素的交换。这样比冒泡排序减少了交换次数。</p><p><img src="https://gitee.com/missingnine/own-image-store/raw/master/202106/SEL.gif" class="lazyload placeholder" data-srcset="https://gitee.com/missingnine/own-image-store/raw/master/202106/SEL.gif" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="SEL.gif"></p><h4 id="1-基本实现"><a href="#1-基本实现" class="headerlink" title="1. 基本实现"></a>1. 基本实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">189</span>, -<span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">78</span>&#125;;</span><br><span class="line">    selectionSort(arr);</span><br><span class="line">    Arrays.stream(arr).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, length = arr.length, minIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环进行了 &quot;</span> + count + <span class="string">&quot; 次&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">循环进行了 <span class="number">15</span> 次</span><br><span class="line">-<span class="number">6</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">78</span></span><br><span class="line"><span class="number">189</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-优化版本1"><a href="#2-优化版本1" class="headerlink" title="2. 优化版本1"></a>2. 优化版本1</h4><p>既然每轮遍历时找出了最小值，同时把最大值也顺便找出来。这就是二元选择排序的思想。</p><p>使用二元选择排序，每轮选择时记录最小值和最大值，可以把数组需要遍历的范围缩小一倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">189</span>, -<span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">78</span>&#125;;</span><br><span class="line">    selectionSort(arr);</span><br><span class="line">    Arrays.stream(arr).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex, maxIndex,count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[maxIndex] &lt; arr[j]) &#123;</span><br><span class="line">                maxIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">        <span class="keyword">if</span> (maxIndex == i) maxIndex = minIndex;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = arr.length - <span class="number">1</span> - i;</span><br><span class="line">        temp = arr[lastIndex];</span><br><span class="line">        arr[lastIndex] = arr[maxIndex];</span><br><span class="line">        arr[maxIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环进行了 &quot;</span> + count + <span class="string">&quot; 次&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">循环进行了 <span class="number">9</span> 次</span><br><span class="line">-<span class="number">6</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">78</span></span><br><span class="line"><span class="number">189</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从代码可以看出，虽然二元选择排序最外层的遍历范围缩小了，但 for 循环内做的事情翻了一倍。也就是说二元选择排序无法将选择排序的效率提升一倍。但实测会发现二元选择排序的速度确实比选择排序的速度快一点点。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
