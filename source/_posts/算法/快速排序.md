---
title: 快速排序
date: 2021-06-20 16:49:11
tags: [算法,排序]
categories: 算法
---

快速排序算法由 C. A. R. Hoare 在 1960 年提出。它的时间复杂度也是 O(nlogn)，但它在时间复杂度为O(nlogn)级的几种排序算法中，大多数情况下效率更高，所以快速排序的应用非常广泛。再加上快速排序所采用的分治思想非常实用，使得快速排序深受面试官的青睐，所以掌握快速排序的思想尤为重要。

快速排序算法的基本思想是：

- 从数组中取出一个数，称之为基数（pivot）
- 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域
- 将左右两个区域视为两个数组，重复前两个步骤，直到排序完成

事实上，快速排序的每一次遍历，都将基数摆到了最终位置上。第一轮遍历排好 1 个基数，第二轮遍历排好 2 个基数（每个区域一个基数，但如果某个区域为空，则此轮只能排好一个基数），第三轮遍历排好 4 个基数（同理，最差的情况下，只能排好一个基数），以此类推。总遍历次数为 logn～n 次，每轮遍历的时间复杂度为O(n)，所以很容易分析出快速排序的时间复杂度为 O(nlogn)～ O(n^2)平均时间复杂度为O(nlogn)。

*让我们来看一下快速排序的动图吧*

![image.png](/medias/images/QUI.gif)


## 快速排序递归框架
根据我们分析出的思路，先搭出快速排序的架子：

```Java
public static void quickSort(int[] arr) {
  quickSort(arr, 0, arr.length - 1);
}
public static void quickSort(int[] arr, int start, int end) {
  // 将数组分区，并获得中间值的下标
  int middle = partition(arr, start, end);
  // 对左边区域快速排序
  quickSort(arr, start, middle - 1);
  // 对右边区域快速排序
  quickSort(arr, middle + 1, end);
}
public static int partition(int[] arr, int start, int end) {
  // TODO: 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标
}
```

> partition 意为“划分”，我们期望 partition 函数做的事情是：将 arr 从 start 到 end 这一区间的值分成两个区域，左边区域的每个数都比基数小，右边区域的每个数都比基数大，然后返回中间值的下标。

只要有了这个函数，我们就能写出快速排序的递归函数框架。首先调用 partition 函数得到中间值的下标 middle，然后对左边区域执行快速排序，也就是递归调用 quickSort(arr, start, middle - 1)，再对右边区域执行快速排序，也就是递归调用 quickSort(arr, middle + 1, end)。

现在还有一个问题，何时退出这个递归函数呢？

## 退出递归的边界条件

很容易想到，当某个区域只剩下一个数字的时候，自然不需要排序了，此时退出递归函数。实际上还有一种情况，就是某个区域只剩下 0 个数字时，也需要退出递归函数。当 middle 等于 start 或者 end 时，就会出现某个区域剩余数字为 0。

所以我们可以通过这种方式退出递归函数：

```Java
public static void quickSort(int[] arr, int start, int end) {
 // 将数组分区，并获得中间值的下标
  int middle = partition(arr, start, end);
  // 当左边区域中至少有 2 个数字时，对左边区域快速排序
  if (start != middle && start != middle - 1) quickSort(arr, start, middle - 1);
  // 当右边区域中至少有 2 个数字时，对右边区域快速排序
  if (middle != end && middle != end - 1) quickSort(arr, middle + 1, end);
}
```

在递归之前，先判断此区域剩余数字是否为 0 个或者 1 个，当数字至少为 2 个时，才执行这个区域的快速排序。因为我们知道 middle >= start && middle <= end 必然成立，所以判断剩余区域的数字为 0 个或者 1 个也就是指 start 或 end 与 middle 相等或相差 1。

我们来分析一下这四个判断条件：

当 start == middle 时，相当于 quickSort(arr, start, middle - 1) 中的 start == end + 1

当 start == middle - 1 时，相当于 quickSort(arr, start, middle - 1) 中的 start == end

当 middle == end时，相当于 quickSort(arr, middle + 1, end) 中的 start == end + 1

当 middle == end -1时，相当于 quickSort(arr, middle + 1, end) 中的 start == end

综上，我们可以将此边界条件统一移到 quickSort 函数之前：

```Java
func quickSortRecurison(arr []int,start,end int){
  if start == end || start = end + 1{
      return 
  }
  middle = partition(arr,start,end)
  quickSortRecurison(arr,start,middle-1)
  qucikSortRecurison(arr,midlle+1,end)
}
```

更进一步，由上文所说的 middle >= start && middle <= end 可以推出，除了start == end || start == end + 1这两个条件之外，其他的情况下 start 都小于 end。所以我们可以将这个判断条件再次简写为：

```Java
func quickSortRecurison(arr []int,start,end int){
  if start >= end{
      return 
  }
  middle := partition(arr,start,end)
  quickSortRecurison(arr,start,middle-1)
  quickSortRecursion(arr,midlle+1,end)
}
```

这样我们就写出了最简洁版的边界条件，我们需要知道，这里的 start >= end 实际上只有两种情况：

- start == end: 表明区域内只有一个数字
- start == end + 1: 表明区域内一个数字也没有
不会存在 start 比 end 大 2 或者大 3 之类的。

## 分区算法实现
快速排序中最重要的便是分区算法，也就是 partition 函数。大多数人都能说出快速排序的整体思路，但实现起来却很难一次写对。主要问题就在于分区时存在的各种边界条件，需要读者亲自动手实践才能加深体会。

上文已经说到，partition 函数需要做的事情就是将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标。那么首先我们要做的事情就是选择一个基数，基数我们一般称之为 pivot，意为“轴”。整个数组就像围绕这个轴进行旋转，小于轴的数字旋转到左边，大于轴的数字旋转到右边。

## 基数的选择
基数的选择没有固定标准，随意选择区间内任何一个数字做基数都可以。通常来讲有三种选择方式：

- 选择第一个元素作为基数
- 选择最后一个元素作为基数
- 选择区间内一个随机元素作为基数

选择的基数不同，算法的实现也不同。实际上第三种选择方式的平均时间复杂度是最优的，待会分析时间复杂度时我们会详细说明。

本文通过第一种方式来讲解快速排序：

```Java
func partition(arr []int,start,end int){
  //取第一个数为基数
  pivot := arr[start]
  //从第二个数开始分区
  left = start + 1
  //右边界
  right = end
}
```

## 最简单的分区算法
分区的方式也有很多种，最简单的思路是：从 left 开始，遇到比基数大的数，就交换到数组最后，并将 right 减一，直到 left 和 right 相遇，此时数组就被分成了左右两个区域。再将基数和中间的数交换，返回中间值的下标即可。

按照这个思路，我们敲出了如下代码：

```Java
func swap(arr []int,i,j int){
  arr[i] = arr[i] ^ arr[j]
  arr[j] = arr[j] ^ arr[i]
  arr[i] = arr[i] ^ arr[j]
}

func quickSort(arr []int){
  quickSortRecursion(arr,0,len(arr)-1)
}

func quickSortRecursion(arr []int,start,end int){
  if start >= end {
      return 
  }
  middle := partition(arr,start,end)
  quickSortRecursion(arr,start,middle-1)
  quickSortRecursion(arr,middle+1,end)
}

func partition(arr []int,start,end int)int{
  pivot := start
  left = start + 1
  right = end
  for left < right{
      for arr[left] <= pivot && left < right{
          left ++
      }
      //left找到大于基数的数，停下来
      if left != right{
          swap(arr,left,right)
          right--
      }

  }

  if left == right && arr[right] > pivot{
      right--
  }
  if left != start{
      swap(arr,left,start)
  }

  return right
}
```

因为我们选择了数组的第一个元素作为基数，并且分完区后，会执行将基数和中间值交换的操作，这就意味着交换后的中间值会被分到左边区域。所以我们需要保证中间值的下标是分区完成后，最后一个比基数小的值，这里我们用 right 来记录这个值。

这段代码有一个细节。首先，在交换 left 和 right 之前，我们判断了 left != right，这是因为如果剩余的数组都比基数小，则 left 会加到 right 才停止，这时不应该发生交换。因为 right 已经指向了最后一个比基数小的值。

但这里的拦截可能会拦截到一种错误情况，如果剩余的数组只有最后一个数比基数大，left 仍然加到 right 停止了，但我们并没有发生交换。所以我们在退出循环后，单独比较了 arr[right] 和 pivot。

实际上，这行单独比较的代码非常巧妙，一共处理了三种情况：

- 一是刚才提到的剩余数组中只有最后一个数比基数大的情况
- 二是 left 和 right 区间内只有一个值，则初始状态下， left == right，所以 while (left < right) 根本不会进入，所以此时我们单独比较这个值和基数的大小关系
- 三是剩余数组中每个数都比基数大，此时 right 会持续减小，直到和 left 相等退出循环，此时 left 所在位置的值还没有和 pivot 进行比较，所以我们单独比较 left 所在位置的值和基数的大小关系

## 双指针分区算法
除了上述的分区算法外，还有一种双指针的分区算法更为常用：从 left 开始，遇到比基数大的数，记录其下标；再从 right 往前遍历，找到第一个比基数小的数，记录其下标；然后交换这两个数。继续遍历，直到 left 和 right 相遇。然后就和刚才的算法一样了，交换基数和中间值，并返回中间值的下标。

代码如下：

```Java
func quickSort(arr []int){

  quickSortRescursion(arr,0,len(arr)-1)

}

func quickSortRescursion(arr []int,start,end int){
  if start >= end {
      return 
  }
  //求分区中轴，把数组分区
  middle := partition(arr,start,end)
  //向左分区递归，对左分区进行排序
  quickSortRescursion(arr,start,middle-1)
  //向右分区递归，对右分区进行排序
  quickSortRescursion(arr,middle+1,end)
} 

func partition(arr []int,start,end int)int{
  //基数
  pivot := arr[start]
  left := start+1
  right := end

  for left < right{
      for left < right && arr[left] <= pivot{
          left++
      }
      for left < right && arr[right] >= pivot{
          right--
      } 

      if left < right{
          swap(arr,left,right)
          left++
          right--
      }
  }
    // 如果 left 和 right 相等，单独比较 arr[right] 和 pivot
  if left == right && arr[right] > pivot{
      right--
  }
  // 将基数和轴交换
  if right != start{
  swap(arr,right,start)
  }
  return right
}
```

同样地，我们需要在退出循环后，单独比较 left 和 right 的值。

## 时间复杂度 & 空间复杂度
平均时间复杂度为O(nlogn)，最坏的时间复杂度为O(n^2)，空间复杂度与递归的层数有关，每层递归会生成一些临时变量，所以空间复杂度为 O(logn)~ O(n)，平均空间复杂度为O(logn)

为什么说随机选择剩余数组中的一个元素作为基数的方案平均复杂度是最优的呢？什么情况下快速排序算法的时间复杂度最高，一共有两种情况。

- 数组为正序
- 数组为逆序

理想中的快速排序在第 k 轮遍历中，可以排好 2^(k-1)个基数。但从图中我们发现，当数组原本为正序或逆序时，我们将第一个数作为基数的话，每轮分区后，都有一个区域是空的，也就是说数组中剩下的数字都被分到了同一个区域！这就导致了每一轮遍历只能排好一个基数。所以总的比较次数为 (n - 1) + (n - 2) + (n - 3) + … + 1 次，由等差数列求和公式可以计算出总的比较次数为 n(n - 1)/2 次，此时快速排序的时间复杂度达到了 O(n^2)级。

## 稳定性
从代码实现中可以分析出，快速排序是一种不稳定的排序算法，在分区过程中，相同数字的相对顺序可能会被修改。

## 快速排序的优化思路
- 1.每轮选择基数时，从剩余的数组中随机选择一个数字作为基数。这样每轮都选到最大或最小值的概率就会变得很低了。所以我们才说用这种方式选择基数，其平均时间复杂度是最优的
- 2.三数取中，待排序序列中low、mid、high三个位置上数据进行排序，取他们中间的那个数据作为枢轴，并用0下标元素存储枢轴。
